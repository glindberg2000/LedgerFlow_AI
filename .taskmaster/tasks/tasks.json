{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create TaxYear (Binder) Model",
        "description": "Create the TaxYear model that represents a binder for a specific client and tax year, serving as the foundation for the binder-centric workflow.",
        "details": "Create a new Django model called TaxYear with the following fields:\n- business_profile: ForeignKey to BusinessProfile\n- year: IntegerField or CharField to store the tax year\n- status: CharField with choices (e.g., 'not_started', 'in_progress', 'complete', 'needs_review')\n- notes: TextField (optional)\n- created_at: DateTimeField (auto_now_add=True)\n- updated_at: DateTimeField (auto_now=True)\n\nExample implementation:\n```python\nfrom django.db import models\nfrom django.utils.translation import gettext_lazy as _\n\nclass TaxYear(models.Model):\n    STATUS_CHOICES = [\n        ('not_started', _('Not Started')),\n        ('in_progress', _('In Progress')),\n        ('complete', _('Complete')),\n        ('needs_review', _('Needs Review')),\n    ]\n    \n    business_profile = models.ForeignKey('profiles.BusinessProfile', on_delete=models.CASCADE, related_name='tax_years')\n    year = models.CharField(max_length=10)\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='not_started')\n    notes = models.TextField(blank=True, null=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        unique_together = ['business_profile', 'year']\n        ordering = ['-year']\n    \n    def __str__(self):\n        return f\"{self.business_profile.name} - {self.year}\"\n```\n\nRegister the model in admin.py with a basic ModelAdmin class.",
        "testStrategy": "1. Write unit tests to verify model creation with required fields\n2. Test unique constraint on business_profile and year\n3. Test string representation\n4. Test relationship with BusinessProfile (can access tax_years from a business profile)\n5. Verify admin registration works by accessing the admin page",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Refactor ChecklistItem Model",
        "description": "Update the ChecklistItem model to link to TaxYear instead of directly to BusinessProfile, enabling the binder-centric organization.",
        "details": "Modify the existing ChecklistItem model to:\n1. Remove the direct FK to BusinessProfile\n2. Add a FK to TaxYear\n3. Update status field to match the required states\n4. Ensure all existing methods and properties are updated\n\n```python\nclass ChecklistItem(models.Model):\n    STATUS_CHOICES = [\n        ('not_started', _('Not Started')),\n        ('in_progress', _('In Progress')),\n        ('complete', _('Complete')),\n        ('needs_review', _('Needs Review')),\n    ]\n    \n    # Replace business_profile FK with tax_year FK\n    tax_year = models.ForeignKey('TaxYear', on_delete=models.CASCADE, related_name='checklist_items')\n    form_code = models.CharField(max_length=100)\n    title = models.CharField(max_length=255)\n    description = models.TextField(blank=True, null=True)\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='not_started')\n    notes = models.TextField(blank=True, null=True)\n    # Keep other existing fields\n    \n    class Meta:\n        ordering = ['form_code']\n        unique_together = ['tax_year', 'form_code']\n    \n    def __str__(self):\n        return f\"{self.form_code}: {self.title}\"\n    \n    @property\n    def business_profile(self):\n        # For backward compatibility\n        return self.tax_year.business_profile\n```\n\nCreate a data migration to:\n1. Create TaxYear instances for each unique BusinessProfile/year combination in existing data\n2. Link ChecklistItems to the appropriate TaxYear\n3. Handle any data inconsistencies",
        "testStrategy": "1. Write unit tests for the updated model structure\n2. Create test cases for the data migration\n3. Verify existing functionality still works with the new model structure\n4. Test the backward compatibility property\n5. Verify admin interface correctly displays the relationships",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Refactor ChecklistAttachment Model",
        "description": "Update the ChecklistAttachment model to maintain proper relationships with the refactored ChecklistItem model and add new fields for enhanced attachment management.",
        "details": "Modify the ChecklistAttachment model to:\n1. Ensure the FK to ChecklistItem is maintained\n2. Add a direct FK to TaxYear for easier querying\n3. Add fields for tagging and tracking upload dates\n\n```python\nclass ChecklistAttachment(models.Model):\n    checklist_item = models.ForeignKey('ChecklistItem', on_delete=models.CASCADE, related_name='attachments')\n    tax_year = models.ForeignKey('TaxYear', on_delete=models.CASCADE, related_name='attachments')\n    file = models.FileField(upload_to='checklist_attachments/%Y/%m/%d/')\n    filename = models.CharField(max_length=255)\n    tag = models.CharField(max_length=100, blank=True, null=True)\n    uploaded_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    notes = models.TextField(blank=True, null=True)\n    \n    class Meta:\n        ordering = ['-uploaded_at']\n    \n    def __str__(self):\n        return self.filename\n    \n    def save(self, *args, **kwargs):\n        # Auto-populate tax_year from checklist_item if not provided\n        if not self.tax_year_id and self.checklist_item_id:\n            self.tax_year = self.checklist_item.tax_year\n        super().save(*args, **kwargs)\n```\n\nCreate a data migration to:\n1. Update existing ChecklistAttachment records to link to the appropriate TaxYear\n2. Set default values for new required fields",
        "testStrategy": "1. Write unit tests for the updated model\n2. Test the auto-population of tax_year in the save method\n3. Verify file uploads work correctly\n4. Test the relationship navigation (can access attachments from TaxYear and ChecklistItem)\n5. Verify data migration correctly links existing attachments",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create BinderSection Model (Optional)",
        "description": "Implement the optional BinderSection model to allow grouping of checklist items within a binder for better organization.",
        "details": "Create a new Django model called BinderSection:\n\n```python\nclass BinderSection(models.Model):\n    tax_year = models.ForeignKey('TaxYear', on_delete=models.CASCADE, related_name='sections')\n    name = models.CharField(max_length=255)\n    description = models.TextField(blank=True, null=True)\n    order = models.PositiveIntegerField(default=0)\n    \n    class Meta:\n        ordering = ['order', 'name']\n        unique_together = ['tax_year', 'name']\n    \n    def __str__(self):\n        return self.name\n```\n\nUpdate the ChecklistItem model to include an optional section field:\n\n```python\n# Add to ChecklistItem model\nsection = models.ForeignKey('BinderSection', on_delete=models.SET_NULL, \n                          related_name='checklist_items', \n                          blank=True, null=True)\n```\n\nCreate admin interfaces for managing sections and assigning checklist items to sections.",
        "testStrategy": "1. Write unit tests for the BinderSection model\n2. Test the relationship between BinderSection and ChecklistItem\n3. Verify ordering works correctly\n4. Test admin interface for creating and managing sections\n5. Verify that checklist items can be assigned to sections",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Binder Admin UI",
        "description": "Create a new admin interface for the binder-centric workflow, allowing users to navigate from client to year to binder dashboard.",
        "details": "Implement a custom admin interface for the binder-centric workflow:\n\n1. Create a custom ModelAdmin for TaxYear with list and detail views\n2. Implement a dashboard view that shows:\n   - Binder summary (client, year, status)\n   - Progress bar for checklist completion\n   - Sections (if implemented) with their checklist items\n   - Attachments related to the binder\n   - Quick action buttons\n\n```python\nfrom django.contrib import admin\nfrom django.urls import path\nfrom django.template.response import TemplateResponse\n\nclass TaxYearAdmin(admin.ModelAdmin):\n    list_display = ['business_profile', 'year', 'status', 'get_completion_percentage']\n    list_filter = ['year', 'status', 'business_profile']\n    search_fields = ['business_profile__name', 'year', 'notes']\n    \n    def get_urls(self):\n        urls = super().get_urls()\n        custom_urls = [\n            path('<int:tax_year_id>/dashboard/',\n                 self.admin_site.admin_view(self.binder_dashboard),\n                 name='binder_dashboard'),\n        ]\n        return custom_urls + urls\n    \n    def get_completion_percentage(self, obj):\n        total = obj.checklist_items.count()\n        if total == 0:\n            return '0%'\n        completed = obj.checklist_items.filter(status='complete').count()\n        percentage = int((completed / total) * 100)\n        return f\"{percentage}%\"\n    get_completion_percentage.short_description = 'Completion'\n    \n    def binder_dashboard(self, request, tax_year_id):\n        tax_year = self.get_object(request, tax_year_id)\n        \n        # Get sections if implemented, otherwise None\n        try:\n            sections = tax_year.sections.all()\n        except AttributeError:\n            sections = None\n        \n        # Get checklist items, grouped by section if available\n        if sections:\n            items_by_section = {}\n            for section in sections:\n                items_by_section[section] = section.checklist_items.all()\n            unsectioned_items = tax_year.checklist_items.filter(section__isnull=True)\n        else:\n            items_by_section = None\n            unsectioned_items = tax_year.checklist_items.all()\n        \n        # Get attachments\n        attachments = tax_year.attachments.all()\n        \n        context = {\n            'title': f'Binder Dashboard: {tax_year}',\n            'tax_year': tax_year,\n            'sections': sections,\n            'items_by_section': items_by_section,\n            'unsectioned_items': unsectioned_items,\n            'attachments': attachments,\n            'completion_percentage': self.get_completion_percentage(tax_year),\n            # Include other required admin context\n            **self.admin_site.each_context(request),\n        }\n        \n        return TemplateResponse(request, 'admin/binder_dashboard.html', context)\n\nadmin.site.register(TaxYear, TaxYearAdmin)\n```\n\nCreate the corresponding template (admin/binder_dashboard.html) with sections for:\n- Binder header and progress\n- Checklist items (grouped by section if available)\n- Attachments\n- Quick actions",
        "testStrategy": "1. Write tests for the custom admin views\n2. Test the dashboard view with various data scenarios\n3. Verify the completion percentage calculation\n4. Test navigation between clients, years, and the dashboard\n5. Verify all UI elements render correctly\n6. Test with and without sections to ensure both workflows work",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Checklist Management in Binder UI",
        "description": "Add functionality to manage checklist items within the binder dashboard, including status updates, notes, and section assignment.",
        "details": "Enhance the binder dashboard with checklist management features:\n\n1. Add inline editing for checklist items\n2. Implement status toggle buttons\n3. Add notes editing functionality\n4. If sections are implemented, allow drag-and-drop between sections\n\n```python\n# Add to TaxYearAdmin\nclass ChecklistItemInline(admin.TabularInline):\n    model = ChecklistItem\n    extra = 0\n    fields = ['form_code', 'title', 'status', 'notes']\n    readonly_fields = ['form_code', 'title']\n    can_delete = False\n    \n    def has_add_permission(self, request, obj=None):\n        return False\n\n# Add to binder_dashboard view\ndef binder_dashboard(self, request, tax_year_id):\n    tax_year = self.get_object(request, tax_year_id)\n    \n    # Handle POST requests for updating checklist items\n    if request.method == 'POST' and 'update_checklist' in request.POST:\n        item_id = request.POST.get('item_id')\n        new_status = request.POST.get('status')\n        notes = request.POST.get('notes')\n        section_id = request.POST.get('section_id')\n        \n        item = tax_year.checklist_items.get(id=item_id)\n        if new_status:\n            item.status = new_status\n        if notes is not None:\n            item.notes = notes\n        if section_id:\n            item.section_id = section_id if section_id != 'none' else None\n        item.save()\n        \n        # Redirect to avoid form resubmission\n        return redirect('admin:binder_dashboard', tax_year_id=tax_year_id)\n    \n    # Rest of the view code...\n```\n\nCreate JavaScript for the dashboard to handle:\n- AJAX updates for status changes\n- Notes editing with auto-save\n- Section assignment (if implemented)\n- Progress bar updates\n\nUpdate the template to include forms and UI elements for these interactions.",
        "testStrategy": "1. Write tests for the checklist item update functionality\n2. Test status changes and verify they update the progress bar\n3. Test notes editing and saving\n4. If implemented, test section assignment\n5. Verify all UI interactions work correctly\n6. Test edge cases like concurrent edits",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Attachment Management in Binder UI",
        "description": "Add functionality to manage attachments within the binder dashboard, including uploads, downloads, tagging, and linking to checklist items.",
        "details": "Enhance the binder dashboard with attachment management features:\n\n1. Implement file upload functionality\n2. Add tagging and notes for attachments\n3. Link attachments to checklist items\n4. Provide download and preview options\n\n```python\n# Add to TaxYearAdmin\nclass ChecklistAttachmentInline(admin.TabularInline):\n    model = ChecklistAttachment\n    extra = 1\n    fields = ['file', 'filename', 'tag', 'checklist_item', 'notes']\n    \n    def get_formset(self, request, obj=None, **kwargs):\n        formset = super().get_formset(request, obj, **kwargs)\n        if obj:\n            formset.form.base_fields['checklist_item'].queryset = obj.checklist_items.all()\n        return formset\n\n# Add to binder_dashboard view\ndef binder_dashboard(self, request, tax_year_id):\n    tax_year = self.get_object(request, tax_year_id)\n    \n    # Handle file uploads\n    if request.method == 'POST' and 'upload_attachment' in request.POST:\n        form = ChecklistAttachmentForm(request.POST, request.FILES)\n        if form.is_valid():\n            attachment = form.save(commit=False)\n            attachment.tax_year = tax_year\n            attachment.save()\n            return redirect('admin:binder_dashboard', tax_year_id=tax_year_id)\n    else:\n        form = ChecklistAttachmentForm(initial={'tax_year': tax_year})\n        form.fields['checklist_item'].queryset = tax_year.checklist_items.all()\n    \n    # Rest of the view code...\n    context['attachment_form'] = form\n```\n\nCreate a form for attachment uploads:\n\n```python\nclass ChecklistAttachmentForm(forms.ModelForm):\n    class Meta:\n        model = ChecklistAttachment\n        fields = ['file', 'filename', 'tag', 'checklist_item', 'notes']\n        widgets = {\n            'notes': forms.Textarea(attrs={'rows': 2}),\n        }\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.instance.filename and self.instance.file:\n            self.initial['filename'] = os.path.basename(self.instance.file.name)\n```\n\nUpdate the template to include:\n- File upload form\n- Attachment listing with download links\n- Tagging interface\n- Attachment-to-checklist item linking",
        "testStrategy": "1. Test file upload functionality with various file types and sizes\n2. Verify attachments are correctly linked to checklist items and tax years\n3. Test tagging and filtering by tags\n4. Test download functionality\n5. Verify proper error handling for invalid uploads\n6. Test UI interactions for attachment management",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Update Bootloader for Multi-Binder Sample Data",
        "description": "Enhance the bootloader to create multiple binders (tax years) for the sample client to demonstrate multi-year support.",
        "details": "Modify the existing bootloader code to:\n\n1. Create multiple TaxYear instances for the sample client\n2. Initialize checklist items for each tax year from the canonical template\n3. Create sample attachments for demonstration\n\n```python\nfrom django.core.management.base import BaseCommand\nfrom profiles.models import BusinessProfile\nfrom tax.models import TaxYear, ChecklistItem, ChecklistAttachment\nimport json\nimport os\nfrom django.conf import settings\n\nclass Command(BaseCommand):\n    help = 'Bootstraps sample data for the binder feature'\n    \n    def handle(self, *args, **options):\n        # Get or create sample business profile\n        business, created = BusinessProfile.objects.get_or_create(\n            name=\"Sample Business LLC\",\n            defaults={\n                'address': '123 Main St',\n                'city': 'Anytown',\n                'state': 'CA',\n                'zip_code': '90210',\n                'email': 'sample@example.com',\n                'phone': '555-123-4567',\n            }\n        )\n        \n        # Create multiple tax years (binders)\n        current_year = 2023\n        for year in range(current_year-2, current_year+1):\n            tax_year, created = TaxYear.objects.get_or_create(\n                business_profile=business,\n                year=str(year),\n                defaults={\n                    'status': 'in_progress' if year == current_year else 'complete',\n                    'notes': f'Sample tax year {year} for demonstration',\n                }\n            )\n            \n            if created:\n                self.stdout.write(f\"Created tax year {year} for {business.name}\")\n                \n                # Load checklist template\n                template_path = os.path.join(settings.BASE_DIR, 'profiles/bootstrap/tax_checklist_index.json')\n                with open(template_path, 'r') as f:\n                    checklist_template = json.load(f)\n                \n                # Create checklist items from template\n                for item_data in checklist_template:\n                    item = ChecklistItem.objects.create(\n                        tax_year=tax_year,\n                        form_code=item_data['form_code'],\n                        title=item_data['title'],\n                        description=item_data.get('description', ''),\n                        status='complete' if year < current_year else 'not_started',\n                    )\n                    \n                    # For completed years, add sample attachments\n                    if year < current_year:\n                        sample_file_path = os.path.join(settings.BASE_DIR, 'profiles/bootstrap/sample_files/sample.pdf')\n                        if os.path.exists(sample_file_path):\n                            with open(sample_file_path, 'rb') as f:\n                                attachment = ChecklistAttachment(\n                                    checklist_item=item,\n                                    tax_year=tax_year,\n                                    filename=f\"{item.form_code}_sample.pdf\",\n                                    tag=\"Sample\",\n                                )\n                                attachment.file.save(f\"{item.form_code}_sample.pdf\", f)\n                                \n        self.stdout.write(self.style.SUCCESS('Successfully bootstrapped sample data'))\n```\n\nEnsure sample files are available in the bootstrap directory or create placeholder files as needed.",
        "testStrategy": "1. Test the bootloader command with a clean database\n2. Verify multiple tax years are created for the sample client\n3. Check that checklist items are properly initialized from the template\n4. Verify sample attachments are created for past years\n5. Test idempotency (running the command multiple times should not create duplicates)\n6. Verify the sample data demonstrates all features of the binder model",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Parallel UI Support",
        "description": "Configure the system to support both the legacy admin interface and the new binder-centric interface simultaneously for safe migration and testing.",
        "details": "Implement parallel UI support to allow both interfaces to coexist:\n\n1. Create separate admin site instances for legacy and new interfaces\n2. Add configuration option to enable/disable new interface\n3. Provide clear navigation between interfaces\n\n```python\n# In admin.py or a separate admin_sites.py file\nfrom django.contrib.admin import AdminSite\nfrom django.conf import settings\n\nclass LegacyAdminSite(AdminSite):\n    site_header = 'Legacy Admin Interface'\n    site_title = 'Legacy Admin'\n    index_title = 'Legacy Admin Dashboard'\n\nclass BinderAdminSite(AdminSite):\n    site_header = 'Binder Admin Interface'\n    site_title = 'Binder Admin'\n    index_title = 'Binder Admin Dashboard'\n\n# Create instances\nlegacy_admin_site = LegacyAdminSite(name='legacy_admin')\nbinder_admin_site = BinderAdminSite(name='binder_admin')\n\n# Register models with appropriate sites\nlegacy_admin_site.register(BusinessProfile, LegacyBusinessProfileAdmin)\n# Register old-style ChecklistItem admin if needed\n\nbinder_admin_site.register(BusinessProfile, BusinessProfileAdmin)\nbinder_admin_site.register(TaxYear, TaxYearAdmin)\n# Register other models for the binder interface\n```\n\nUpdate URLs to include both admin sites:\n\n```python\n# In urls.py\nfrom django.urls import path, include\nfrom .admin_sites import legacy_admin_site, binder_admin_site\n\nurlpatterns = [\n    path('admin/', include([\n        path('', binder_admin_site.urls),\n        path('legacy/', legacy_admin_site.urls),\n    ])),\n    # Other URL patterns\n]\n```\n\nAdd navigation links between interfaces:\n\n```python\n# In admin templates or by overriding admin templates\n# Add to admin/base.html for each site\n\n# In binder admin\n<li><a href=\"{% url 'legacy_admin:index' %}\">Switch to Legacy Admin</a></li>\n\n# In legacy admin\n<li><a href=\"{% url 'admin:index' %}\">Switch to Binder Admin</a></li>\n```\n\nAdd configuration option in settings.py:\n\n```python\n# In settings.py\nBINDER_UI_ENABLED = True  # Can be toggled to disable new UI\n```\n\nUpdate URL patterns based on the setting:\n\n```python\n# In urls.py\nif settings.BINDER_UI_ENABLED:\n    urlpatterns = [\n        path('admin/', include([\n            path('', binder_admin_site.urls),\n            path('legacy/', legacy_admin_site.urls),\n        ])),\n        # Other URL patterns\n    ]\nelse:\n    urlpatterns = [\n        path('admin/', legacy_admin_site.urls),\n        # Other URL patterns\n    ]\n```",
        "testStrategy": "1. Test navigation between legacy and new admin interfaces\n2. Verify both interfaces can be accessed simultaneously\n3. Test enabling/disabling the new interface via settings\n4. Verify that data created in one interface is visible in the other\n5. Test with different user permissions to ensure proper access control\n6. Verify that links between interfaces work correctly",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Data Migration Strategy",
        "description": "Create a comprehensive data migration strategy to move existing client data from the legacy model to the new binder-centric model.",
        "details": "Implement a data migration strategy with the following components:\n\n1. Create Django migrations for model changes\n2. Implement a data migration script\n3. Add rollback capability\n4. Provide validation and reporting\n\n```python\n# Create a Django migration file\nfrom django.db import migrations, models\nimport django.db.models.deletion\n\ndef migrate_to_binder_model(apps, schema_editor):\n    BusinessProfile = apps.get_model('profiles', 'BusinessProfile')\n    TaxYear = apps.get_model('tax', 'TaxYear')\n    OldChecklistItem = apps.get_model('tax', 'ChecklistItem')\n    ChecklistAttachment = apps.get_model('tax', 'ChecklistAttachment')\n    \n    # Track migration statistics\n    stats = {\n        'businesses': 0,\n        'tax_years': 0,\n        'checklist_items': 0,\n        'attachments': 0,\n        'errors': [],\n    }\n    \n    # Get all business profiles\n    businesses = BusinessProfile.objects.all()\n    stats['businesses'] = businesses.count()\n    \n    for business in businesses:\n        # Find all unique years in checklist items\n        years = set()\n        for item in OldChecklistItem.objects.filter(business_profile=business):\n            # Extract year from form_code or other field\n            # This depends on how years are currently stored\n            year = '2023'  # Default or extract from data\n            years.add(year)\n        \n        # Create tax years for each business\n        for year in years:\n            tax_year, created = TaxYear.objects.get_or_create(\n                business_profile=business,\n                year=year,\n                defaults={'status': 'in_progress'}\n            )\n            if created:\n                stats['tax_years'] += 1\n            \n            # Update checklist items to point to tax year\n            items = OldChecklistItem.objects.filter(business_profile=business)\n            for item in items:\n                item.tax_year = tax_year\n                item.save()\n                stats['checklist_items'] += 1\n            \n            # Update attachments\n            attachments = ChecklistAttachment.objects.filter(checklist_item__in=items)\n            for attachment in attachments:\n                attachment.tax_year = tax_year\n                attachment.save()\n                stats['attachments'] += 1\n    \n    return stats\n\ndef rollback_binder_migration(apps, schema_editor):\n    # This would restore the old relationships if needed\n    pass\n\nclass Migration(migrations.Migration):\n    dependencies = [\n        ('profiles', '0001_initial'),\n        ('tax', '0001_initial'),\n    ]\n    \n    operations = [\n        # Add TaxYear model\n        migrations.CreateModel(\n            name='TaxYear',\n            fields=[\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n                ('year', models.CharField(max_length=10)),\n                ('status', models.CharField(choices=[('not_started', 'Not Started'), ('in_progress', 'In Progress'), ('complete', 'Complete'), ('needs_review', 'Needs Review')], default='not_started', max_length=20)),\n                ('notes', models.TextField(blank=True, null=True)),\n                ('created_at', models.DateTimeField(auto_now_add=True)),\n                ('updated_at', models.DateTimeField(auto_now=True)),\n                ('business_profile', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='tax_years', to='profiles.BusinessProfile')),\n            ],\n            options={\n                'ordering': ['-year'],\n                'unique_together': {('business_profile', 'year')},\n            },\n        ),\n        \n        # Add tax_year field to ChecklistItem\n        migrations.AddField(\n            model_name='checklistitem',\n            name='tax_year',\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='checklist_items', to='tax.TaxYear'),\n        ),\n        \n        # Add tax_year field to ChecklistAttachment\n        migrations.AddField(\n            model_name='checklistattachment',\n            name='tax_year',\n            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, related_name='attachments', to='tax.TaxYear'),\n        ),\n        \n        # Run data migration\n        migrations.RunPython(migrate_to_binder_model, rollback_binder_migration),\n        \n        # Make tax_year required after data migration\n        migrations.AlterField(\n            model_name='checklistitem',\n            name='tax_year',\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='checklist_items', to='tax.TaxYear'),\n        ),\n        \n        migrations.AlterField(\n            model_name='checklistattachment',\n            name='tax_year',\n            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='attachments', to='tax.TaxYear'),\n        ),\n        \n        # Remove direct business_profile FK from ChecklistItem if it exists\n        migrations.RemoveField(\n            model_name='checklistitem',\n            name='business_profile',\n        ),\n    ]\n```\n\nCreate a management command for manual migration and validation:\n\n```python\nfrom django.core.management.base import BaseCommand\nfrom profiles.models import BusinessProfile\nfrom tax.models import TaxYear, ChecklistItem, ChecklistAttachment\n\nclass Command(BaseCommand):\n    help = 'Migrates data to the binder model and validates the migration'\n    \n    def add_arguments(self, parser):\n        parser.add_argument('--dry-run', action='store_true', help='Run in dry-run mode without making changes')\n        parser.add_argument('--validate', action='store_true', help='Validate existing migration')\n    \n    def handle(self, *args, **options):\n        if options['validate']:\n            self.validate_migration()\n            return\n        \n        dry_run = options['dry_run']\n        if dry_run:\n            self.stdout.write('Running in dry-run mode')\n        \n        # Similar logic to the migration function, but with more detailed reporting\n        # ...\n        \n    def validate_migration(self):\n        # Check for items without tax_year\n        orphaned_items = ChecklistItem.objects.filter(tax_year__isnull=True)\n        if orphaned_items.exists():\n            self.stdout.write(self.style.ERROR(f'Found {orphaned_items.count()} checklist items without tax_year'))\n            for item in orphaned_items[:10]:  # Show first 10\n                self.stdout.write(f'  - {item.id}: {item.form_code}')\n        \n        # Check for attachments without tax_year\n        orphaned_attachments = ChecklistAttachment.objects.filter(tax_year__isnull=True)\n        if orphaned_attachments.exists():\n            self.stdout.write(self.style.ERROR(f'Found {orphaned_attachments.count()} attachments without tax_year'))\n        \n        # Verify all businesses have at least one tax year\n        businesses_without_years = BusinessProfile.objects.filter(tax_years__isnull=True)\n        if businesses_without_years.exists():\n            self.stdout.write(self.style.WARNING(f'Found {businesses_without_years.count()} businesses without tax years'))\n        \n        # Overall statistics\n        self.stdout.write(self.style.SUCCESS(f'Businesses: {BusinessProfile.objects.count()}'))\n        self.stdout.write(self.style.SUCCESS(f'Tax Years: {TaxYear.objects.count()}'))\n        self.stdout.write(self.style.SUCCESS(f'Checklist Items: {ChecklistItem.objects.count()}'))\n        self.stdout.write(self.style.SUCCESS(f'Attachments: {ChecklistAttachment.objects.count()}'))\n```",
        "testStrategy": "1. Create test fixtures with sample data in the old format\n2. Run the migration on the test fixtures and verify the results\n3. Test the rollback functionality\n4. Verify that all relationships are maintained after migration\n5. Test the validation command with various data scenarios\n6. Perform a dry run on production data before actual migration\n7. Create a backup before running the actual migration",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-02T02:28:28.878Z",
      "updated": "2025-07-02T02:28:28.878Z",
      "description": "Tasks for master context"
    }
  }
}